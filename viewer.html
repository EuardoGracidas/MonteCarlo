<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Visor 3D</title>
  <style>
    html,body{margin:0;height:100%;background:#1C1C1C;font-family:system-ui,Arial}
    #app{position:fixed;inset:0}
    #hud{
      position:fixed;top:12px;left:12px;background:rgba(255,255,255,.95);
      border:1px solid #ddd;border-radius:10px;padding:10px 12px;
      box-shadow:0 6px 18px rgba(0,0,0,.12);font-size:13px;line-height:1.5
    }
    #warn{color:#a42525;font-weight:600;margin-top:6px}
  </style>
</head>
<body>
  <div id="app"></div>
  <div id="hud">
    <strong>Modelo 3D</strong><br>
    Arrastra para rotar, rueda para zoom.
    <div>
        <p><b>Energía por capa: </b></p>
        <ul id="capas"></ul>
        <p>
            <b>Energía perdida: </b>
            <i style="color:red" id="energyloss"></i>
        </p>
        <p id="laserinfo"></p>
    </div>
    <div id="warn"></div>
  </div>

  <!-- Three.js (legacy, sin módulos) -->
  <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
  const warnEl = document.getElementById('warn');

  // --- escena básica ---
  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setClearColor(0x1C1C1C, 1);
  renderer.sortObjects = false;
  document.getElementById('app').appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 2000);
  camera.position.set(0, 1.8, 6);
  scene.add(camera);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  // Iluminación sencilla
  scene.add(new THREE.AmbientLight(0xffffff, 1));
  const dir = new THREE.DirectionalLight(0xffffff, 0.1);
  dir.position.set(4,6,5);
  scene.add(dir);

  // --- colores por tipo ---
  const COLORS = {
    piel:"#F8CFCF", dermis:"#F8CFCF", grasa:"#FFF2B0",
    musculo:"#E57373","músculo":"#E57373", tejido:"#F8E0C0",
    tumor:"#B71C1C", generico:"#F6E6D8"
  };
  const colTipo = t=>{
    t=String(t||"").toLowerCase();
    if(t.includes("tumor")) return COLORS.tumor;
    if(t.includes("grasa")||t.includes("adiposo")) return COLORS.grasa;
    if(t.includes("musculo")||t.includes("músculo")) return COLORS.musculo;
    if(t.includes("dermis")||t.includes("piel")) return COLORS.piel;
    if(t.includes("tejido")) return COLORS.tejido;
    return COLORS.generico;
  };

  const root = new THREE.Group(); scene.add(root);
  function clearRoot(){
    while(root.children.length){
      const o = root.children.pop();
      o.traverse?.(n=>{
        n.geometry?.dispose?.();
        if(n.material){
          if(Array.isArray(n.material)) n.material.forEach(m=>m.dispose?.());
          else n.material.dispose?.();
        }
      });
      scene.remove(o);
    }
    scene.add(root);
  }

  // --- construir modelo ---
  // payload esperado:
  // {
  //   Rxy: number (cm),
  //   zBound: number[] (acumulado, cm),
  //   slabIdx: number[],
  //   tipo: string[],
  //   spheres: { index:number, radius:number, tipo:string }[],
  //   tumorCenterZ: number (cm),
  //   tumorCenterX?: number (cm)   <-- NUEVO
  //   tumorCenterY?: number (cm)   <-- NUEVO
  //   tumorColor?: string|number,
  //   energy?: number[],
  //   energyloss?: number|string,
  //   lambda?: number
  // }
  function build(payload){
    const capas = document.getElementById("capas");
    capas.innerHTML = "";
    (payload.slabIdx||[]).forEach((i)=>{
      const li = document.createElement("li");
      li.innerText = payload.tipo[i] + ": " + String(payload.energy?.[i] ?? 0);
      capas.appendChild(li);
    });
    if ((payload.tipo||[]).some(t => /tumor/i.test(t))) {
      const idxTum = payload.tipo.findIndex(t => /tumor/i.test(t));
      const li = document.createElement("li");
      li.innerText = "Tumor: " + String(payload.energy?.[idxTum] ?? 0);
      capas.appendChild(li);
    }

    const laserinfo = document.getElementById("laserinfo");
    laserinfo.style.fontWeight = "bolder";

    let color_laser = 0x000000;
    if(payload.lambda <= 430){
      color_laser = 0x8000FF;
      laserinfo.innerText = "Irradiando con luz UV";
    }else if(payload.lambda > 430 && payload.lambda <= 480){
      color_laser = 0x0037FF;
      laserinfo.innerText = "Irradiando con luz AZUL";
    }else if(payload.lambda > 480 && payload.lambda <= 560){
      color_laser = 0x00DB21;
      laserinfo.innerText = "Irradiando con luz VERDE";
    }else if(payload.lambda > 560 && payload.lambda <= 590){
      color_laser = 0xDBD400;
      laserinfo.innerText = "Irradiando con luz AMARILLA";
    }else if(payload.lambda > 590 && payload.lambda <= 620){
      color_laser = 0xDB9900;
      laserinfo.innerText = "Irradiando con luz NARANJA";
    }else if(payload.lambda > 620){
      color_laser = 0xDB0000;
      laserinfo.innerText = "Irradiando con luz ROJA";
    }
    laserinfo.style.color = `#${color_laser.toString(16).padStart(6, "0")}`;
    document.getElementById("energyloss").innerText = String(payload.energyloss ?? "");

    // Elementos decorativos (cilindro y rayo)
    const geometry = new THREE.CylinderGeometry(0.2,0.2,1,32,1,false,0,Math.PI*2);
    const material = new THREE.MeshBasicMaterial({ color: 0xC7C7C7 });
    const box = new THREE.Mesh(geometry, material);
    box.position.set(0,2,0);
    scene.add(box);

    const geometry2 = new THREE.BoxGeometry(0.05,5,0.05);
    const material2 = new THREE.MeshBasicMaterial({ color: color_laser, opacity:0.2 });
    const box2 = new THREE.Mesh(geometry2, material2);
    box2.position.set(0,0,0);
    scene.add(box2);

    const {
      Rxy,
      zBound = [],
      slabIdx = [],
      tipo = [],
      spheres = [],
      tumorCenterZ,
      tumorCenterX = 0,   // NUEVO
      tumorCenterY = 0,   // NUEVO
      tumorColor,
      energy = []
    } = payload || {};

    // limpieza escena
    clearRoot();
    warnEl.textContent = "";

    // validaciones mínimas
    if (!Array.isArray(zBound) || zBound.length < 2) return;
    const R = Number(Rxy);
    const H = zBound[zBound.length - 1];
    if (!isFinite(R) || R <= 0 || !isFinite(H) || H <= 0) return;

    // utilidades
    const width = 2 * R, depth = 2 * R;
    const zToY = z => (H / 2) - z; // superficie arriba

    // Marco
    {
      const frameGeo = new THREE.BoxGeometry(width, H, depth);
      const frame = new THREE.LineSegments(
        new THREE.EdgesGeometry(frameGeo),
        new THREE.LineBasicMaterial({ color: 0x888888 })
      );
      frame.renderOrder = 0;
      root.add(frame);
    }

    // ----- SLABS -----
    const useIdx = (Array.isArray(slabIdx) && slabIdx.length === (zBound.length - 1))
      ? slabIdx
      : Array.from({length: zBound.length - 1}, (_, i) => i);

    for (let k = 0; k < zBound.length - 1; k++) {
      const z1 = zBound[k], z2 = zBound[k + 1];
      const h  = Math.max(1e-4, z2 - z1);
      const y  = zToY((z1 + z2) / 2);

      const idxFila = useIdx[k] ?? k;
      const nombre = tipo[idxFila] ?? `capa ${k+1}`;
      const mat = new THREE.MeshStandardMaterial({
        color: colTipo(nombre),
        transparent: true, opacity: 0.60,
        depthTest: true, depthWrite: true, side: THREE.DoubleSide
      });

      const slab = new THREE.Mesh(new THREE.BoxGeometry(width, h, depth), mat);
      slab.position.set(0, y, 0);
      slab.renderOrder = 1;
      root.add(slab);

      const edge = new THREE.LineSegments(
        new THREE.EdgesGeometry(new THREE.BoxGeometry(width, h, depth)),
        new THREE.LineBasicMaterial({ color: 0x333333, transparent: true, opacity: 0.25 })
      );
      edge.position.copy(slab.position);
      edge.renderOrder = 1;
      root.add(edge);
    }

    // ----- ESFERAS (tumor + capas concéntricas) -----
    if (Array.isArray(spheres) && spheres.length) {
      const eps = 1e-6;

      // Centro Z válido
      let zc = Number(tumorCenterZ);
      if (!isFinite(zc)) zc = 0;

      // Asegurar que cae dentro de un slab por Z
      let iSlab = -1;
      for (let i = 0; i < zBound.length - 1; i++) {
        if (zc >= zBound[i] && zc < zBound[i + 1]) { iSlab = i; break; }
      }
      if (iSlab === -1 && Math.abs(zc - H) < 1e-9) {
        zc = H - eps;
        for (let i = 0; i < zBound.length - 1; i++) {
          if (zc >= zBound[i] && zc < zBound[i + 1]) { iSlab = i; break; }
        }
      }
      if (iSlab === -1) { iSlab = 0; zc = (zBound[0] + zBound[1]) / 2; }

      const z1 = zBound[iSlab], z2 = zBound[iSlab + 1];
      const yCenter = zToY(zc);

      // NUEVO: Centro lateral (clamp al dominio [-R,+R])
      const xCenter = THREE.MathUtils.clamp(Number(tumorCenterX) || 0, -R, R);
      const zCenter = THREE.MathUtils.clamp(Number(tumorCenterY) || 0, -R, R);

      // Colores
      const tumorCol = (typeof tumorColor === 'string' || typeof tumorColor === 'number')
        ? tumorColor
        : '#ff1744';
      const shellCol = '#7FC5D6';

      const sorted = spheres.slice().sort((a, b) => a.radius - b.radius);

      sorted.forEach(s => {
        const rawR = Number(s.radius);
        if (!isFinite(rawR) || rawR <= 0) return;

        // Recorte en Z para que quepa dentro del slab donde está el centro
        const maxRz = Math.max(1e-4, Math.min(zc - z1, z2 - zc) - eps);
        // Recorte lateral para que no salga de las paredes
        const maxRx = Math.max(1e-4, R - Math.abs(xCenter) - eps);
        const maxRy = Math.max(1e-4, R - Math.abs(zCenter) - eps);
        const maxR  = Math.max(1e-4, Math.min(rawR, maxRz, maxRx, maxRy));

        const isTumor = /tumor/i.test(String(s.tipo || ""));
        const baseColor = isTumor ? tumorCol : shellCol;

        // Esfera
        const mesh = new THREE.Mesh(
          new THREE.SphereGeometry(maxR, 48, 32),
          new THREE.MeshStandardMaterial({
            color: baseColor,
            transparent: true,
            opacity: isTumor ? 0.90 : 0.40,
            depthTest: true, depthWrite: false, side: THREE.DoubleSide
          })
        );
        mesh.position.set(xCenter, yCenter, zCenter); // <--- POSICIÓN 3D ACTUALIZADA
        mesh.renderOrder = 2;
        root.add(mesh);

        const wire = new THREE.Mesh(
          new THREE.SphereGeometry(maxR, 24, 16),
          new THREE.MeshBasicMaterial({
            color: baseColor,
            wireframe: isTumor ? false : true, opacity: isTumor ? 0.9 : 0.5
          })
        );
        wire.position.copy(mesh.position);
        wire.renderOrder = 3;
        root.add(wire);

        const eVal = energy[s.index];
        if (Number.isFinite(eVal)) {
          // aquí podrías añadir etiquetas si lo deseas
        }
      });
    }

    // ----- encuadre de cámara -----
    const box3 = new THREE.Box3().setFromObject(root);
    const size = new THREE.Vector3(); box3.getSize(size);
    const center = new THREE.Vector3(); box3.getCenter(center);
    const maxDim = Math.max(size.x, size.y, size.z);
    const fitDist = maxDim * 1.6 / Math.tan((camera.fov*Math.PI/180)/2);
    camera.position.set(center.x + maxDim * 0.6, center.y + maxDim * 0.6, center.z + fitDist);
    controls.target.copy(center);
    controls.update();
  }

  // Loop
  window.addEventListener('resize', ()=>{
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });
  (function loop(){ requestAnimationFrame(loop); controls.update(); renderer.render(scene,camera); })();

  // postMessage desde tu app
  let started=false;
  function maybeStartOnce(payload){ if(started) return; started=true; build(payload); }
  window.addEventListener('message', ev=>{
    if(!ev?.data || ev.data.type!=="mc3d") return;
    maybeStartOnce(ev.data.payload);
  });

  // demo si se abre solo (puedes borrar este bloque en producción)
  setTimeout(()=>{
    if(started) return;
    maybeStartOnce({
      Rxy: 1.0,
      zBound: [0, 0.3, 0.6, 0.9, 1.2],
      slabIdx: [0,1,2,3],
      tipo: ["grasa","músculo","piel","piel"],
      spheres: [
        { index: 4, radius: 0.08, tipo: "tumor" },
        { index: 5, radius: 0.10, tipo: "esfera" }
      ],
      tumorCenterZ: 0.30,
      tumorCenterX: 0.20,  // mover en X (cm)
      tumorCenterY: -0.15, // mover en Y (cm) -> eje Z en la escena
      tumorColor: "#ff1744",
      energy: [],
      lambda: 633
    });
  }, 300);
  </script>
</body>
</html>
